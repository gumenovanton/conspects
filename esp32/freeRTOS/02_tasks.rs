//>> ЗАДАЧИ
//<< либы
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

//<< как работает
// задача представляет собой отдельную функцию 
// внутри которой есть бесконечный цикл, 
// в котором можно делать что хочешь
// пранировщик то возвращается к ней то уходит от нее
// сохраняя состояние, стек, пеерменные задачи
// это как отдельный поток

//<< этапы создания
- пишем код функции задачи
- настраиваем задачу и добавление в планировщик
- запуск планировщика(это не делаем, так как планировщик в esp32 запущен)

//<< создание функции задачи
// для начала нужно написать код задачи
// задача это функция получающая параметры void* 
// и возвращающая void 
void ATaskFunction( void *pvParameters )
{
    // состояние
    int iVariableExample = 0;
    for( ;; )
    {
    }
    // если выполнила свою работу ее можно удалить
    // но это случается крайне редко
    vTaskDelete( NULL );
}

// задача не может заканчиваться
// ее можно только удалить когда она не нужна
// и пересоздать снова
// задач из этого кода можно запустить сколько угодно

//<< настройка задачи и добавление ее в планировщик
//! настроить и добавить задачу в плонировщик можно когда угодно
//! даже в другой задаче
//! так же можно ее удалить
// задача настраивается функцией xTaskCreate
xTaskCreate( указатель_на_функцию, строка_имя_задачи, размер_стека, параметр_передаваемый_в функцию, приоритет, куда_положить_указатель_на_задачу );
// которая принимает
- размер_стека, для задачи (если стек 32 битный и указать 100, то его размер будет 100*32=3200бит или 100*4=400байт)
- приоритет от 0(минимальный) до числа выбераемого пользователем от души, но лучше ставить диапазон приоритетов по меньше
- ссылка на задачу(для внешнего изменения приоритета или удаления задачи или чтобы усыпить задачу)
// и позващает 
1 - pdTRUE - говорит что задача создана
2 - errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY - ошибка так как в куче нет места

// здесь добавляем задачу в планировщик
xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL );

//<< запуск планировщика
vTaskStartScheduler();

//>> ПРИМЕР
//<< функция задачи

void vTask1( void *pvParameters )
{
const char *pcTaskName = "Task 1 is running\r\n";
volatile unsigned long ul;

  /* Как и большинство задач, эта задача реализована на основе бесконечного цикла. */
  for( ;; )
  {
     /* Вывод на печать имени этой задачи. */
     vPrintString( pcTaskName );

     /* Задержка на некоторый период времени. */
     for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
     {
         /* Этот цикл просто реализует задержку очень грубым методом.
            В цикле не производится никаких действий. Далее будут приведены
            примеры, в которых этот пустой цикл будет заменен соответствующей
            функцией задержки / приостановки задачи (введение задачи в состояние
            сна - sleep). */
     }
  }
}

void vTask2( void *pvParameters )
{
const char *pcTaskName = "Task 2 is running\r\n";
volatile unsigned long ul;

  /* Как и большинство задач, эта задача реализована на основе бесконечного цикла. */
  for( ;; )
  {
     /* Вывод на печать имени этой задачи. */
     vPrintString( pcTaskName );
     /* Задержка на некоторый период времени. */
     for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ )
     {
         /* Этот цикл просто реализует задержку очень грубым методом.
            В цикле не производится никаких действий. Далее будут приведены
            примеры, в которых этот пустой цикл будет заменен соответствующей
            функцией задержки / приостановки задачи (введение задачи в состояние
            сна - sleep). */
     }
  }
}

//<< main
int main( void )
{
  /* Создание одной из двух задач. Имейте в виду, что реальное приложение должно
     проверить возвращаемое значение из вызова xTaskCreate(), чтобы удостовериться,
     что задача была успешно создана. */
  xTaskCreate( vTask1,  /* Указатель на функцию, которая реализует задачу. */
               "Task 1",/* Текстовое имя задачи. Этот параметр нужен только для
                           упрощения отладки. */
               1000,    /* Глубина стека - самые маленькие микроконтроллеры будут
                           использовать значение намного меньше, чем здесь
                           указано. */
               NULL,    /* Мы не используем параметр задачи. */
               1,       /* Задача будет запущена с приоритетом 1. */
               NULL );  /* Мы не будем использовать хендл задачи. */
  /* Создание другой задачи полностью совпадает с созданием первой,
     приоритет задачи тот же. */
  xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL );

  /* Запуск шедулера, после чего задачи запустятся на выполнение. */
  vTaskStartScheduler();

  /* Если все хорошо, то управление в main() никогда не дойдет до этой точки,
     и теперь шедулер будет управлять задачами. Если main() довела управление
     до этого места, то это может означать, что не хватает памяти кучи
     (heap) для создания специальной задачи ожидания (idle task, об этой задаче
     далее). Часть 5 предоставляет больше информации по управлению памятью. */
  for( ;; );
}

//>> IDLE_задача
// задача работающая пока нет задач
// автоматически создается планировщиком с приоритетом 0


//>> ТАЙМЕРЫ
//<< кинуть задачу в состояние wait на период времени
vTaskDelay(время_после_которого_проснется)
// время обычно указываем так - 10 / portTICK_PERIOD_MS
// типо в милисекундах, но не точно, зависит от герцовки freeRTOS

//<< кинуть задачу в состояние wait на период времени от заданной точки
// применяется когда нужна четкая переодичность
// vTaskDelay всегда считает от начала последнего вызова vTaskDelay
// vTaskDelayUntil считает от времени пробуждения задачи
vTaskDelayUntil(N)

void vTaskFunction( void *pvParameters )
{

  // Переменная xLastWakeTime нуждается в инициализации один раз
   portTickType xLastWakeTime = xTaskGetTickCount();

  for( ;; )
  {
     // что то делаем
     // задаем переодичность вызова задачи
     vTaskDelayUntil( &xLastWakeTime, ( 250 / portTICK_RATE_MS ) );
  }
}

//>> ИЗМЕНЕНИЕ ПРИОРИТЕТА ЗАДАЧ
//<< получить приоритет задачи
uxTaskPriorityGet(указатель_на_задачу) 
// возвращает приоритет задачи.

//<< задать приоритет задачи
uxTaskPrioritySet(указатель_на_задачу, значение_приоритета)

//>> ОТКЛЮЧЕНИЕ ЗАДАЧ
vTaskSuspend — глушит задачу, что она перестает отвечать на события. Перестает работать, но не выгружается из памяти, а зависает в текущем состоянии.
vTaskResume — возврат задачи из SUSPEND состояния. Эту функцию нельзя выполнять из обработчика прерывания.
vTaskResumeFromISR — аналогичная команда, но ее как раз можно выполнять из обработчика прерывания, но нельзя запускать вне него. 

//>> УТИЛИТЫ ЗАДАЧ
// не управляют задачами а дают инфу
xTaskGetCurrentTaskHandle — узнать Handle текущей задачи. Зная заголовок можно можно менять ее приоритет, запускать, удалять и так далее.
xTaskGetTickCount — выдает количество тиков с момента запуска планировщика. Это этакий глобальный таймер, отсчитывающий время с начала времен.
xTaskGetSchedulerState — выдает состояние диспетчера. Запущен, работает, выключен и так далее.
uxTaskGetNumberOfTasks — показывает количество загруженных задач. Например если надо определить хватит ли памяти. Или для отладки.
vTaskList — отладочная утилита. В итоговую программу совать ее не следует. При запуске делает большой такой отчет в котором записывает досье на все запущенные задачи. Там и заголовки, имена, состояние, сколько есть памяти, какая глубина стека.
vTaskStartTrace — запуск отладочной трассировки. Данные тоже пишутся в большой такой лог. Который можно по UART скинуть на комп, расшифровать специальной утилиткой и посмотреть что происходило в недрах вашей программы.
ulTaskEndTrace — остановка трассировки.

//>> ЗАВЕРШЕНИЕ ЗАДАЧИ И ПЕРЕДАЧА ДРУГОЙ ЗАДАЧЕ
// когда мне не нужна зацикленность в задаче
// я хочу сделать одно действие
// и после него я хочу сразу выйти из задачи а не держать ее тик
// надо просто написать в конце цикла
taskYIELD();