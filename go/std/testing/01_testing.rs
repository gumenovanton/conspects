package main

import (
	"sort"
	"testing"
)

//>> ОРГАНИЗАЦИЯ МОДУЛЬНОГО ТЕСТИРОВАНИЯ
// тесты лежат в папке пакета
// имеют тот же пакет, соответственно имеют доступ ко всем функциям пакета
// имена файлов тестов заканчиваются на _test.go, типа , simple_test.go
// тест - это функция с именем начинающимся на Test и далее какое то имя, типа TestSum
// и принимают структуру типа testing.T
// в которой и реализованы все методы тестирования

//<< тестирование только экспортируемых функций
// если пакет называется например main
// а в тесте указать пакет main_test,
// но так же положить его в эту же папку
// то тест так же будет привязан к пакету main,
// но доступны будут только экспортируемые функции

//<< проверка покрытия тестами
go test -cover

// _ ПРИМЕР ТЕСТА
func TestSum(t *testing.T) {
	// тестируемые данные
	testValues := []int{10, 20, 30}
	// запускаю функцию обьявленную в пакете main
	_, sum := sortAndTotal(testValues)
	// что ожидаю на выходе
	expected := 60
	// сравниваю результат
	if sum != expected {
		t.Fatalf("Expected %v, Got %v", expected, sum)
	}
}

// --- FAIL: TestSum (0.00s)
//     simple_test.go:33: Expected 60, Got 63
// FAIL

//<< тестов может быть несколько в одном файле
// это так наываемые таьличные тесты

func TestSort(t *testing.T) {
	testValues := []int{1, 279, 48, 12, 3}
	sorted, _ := sortAndTotal(testValues)
	if !sort.IntsAreSorted(sorted) {
		t.Fatalf("Unsorted data %v", sorted)
	}
}

//>> МЕТОДЫ СТРУТУРЫ testing.T
//<< Log(...vals)
// записывает vals в журнал оштбок
//<< Logf(template, ...vals)
// записывает vals по шадлону в журнал ошибок
//<< Fail()
// помечает тест как не пройденый и продолжает тест
//<< FailNow()
// помечает тест как провеленный и прекращает тест
//<< Failed()
// возвращает true, если тест провален,
// используется для прверки внутри теста
//<< Error(...errs)
// связка Log() c Fail()
// то есть печатает errs в журнал ошибок,
// помечает тест как не пройденный но продолжает его
//<< Errorf(template, ...errs)
// связка Logf() c Fail()
// то есть печатает errs в журнал ошибок по шаблону,
// помечает тест как не пройденный но продолжает его
//<< Fatal(...vals)
// связка Log() c FailNow()
// то есть печатает errs в журнал ошибок,
// помечает тест как не пройденный и прекращает его
//<< Fatalf(template, ...vals)
// связка Logf() c FailNow()
// то есть печатает errs в журнал ошибок по шаблону,
// помечает тест как не пройденный и прекращает его

//>> МЕТОДЫ УПРАВЛЕНИЯ ТЕСТАМИ СТРУКТУРЫ testing.T
//<< Run(name, func)
// вызов теса внутри другого теста
// возвращает bool, пройден тест ии нет
//<< SkipNow()
// прекращение теста с отметкой как пропущенный
// используется когда нет смысла продолжать тестирование
//<< Skip(...args)
// связка Log() c SkipNow()
// то есть вывод args в журнал ошибок и пометка теста как пропущеного
//<< Skipа(template, ...args)
// связка Logf() c SkipNow()
// то есть вывод args в журнал ошибок по шаблону и пометка теста как пропущеного
//<< Skiped()
// возвращает пропущен ли тест, используется в ходе теста для проверки состояния

//>> ЗАПУС МОДУЛЬНЫХ ТЕСТОВ
//<< go test
// запуск всех тестов без подробностей

// если все тктсы успешны просто выдаст что все пройдено,
// без информации по конкретным тестам
// но если что то провалилось выдаст инфу по проваленному тесту
// и сообщение журнала ошибок

// --- FAIL: TestSum (0.00s)
//     simple_test.go:33: Expected 60, Got 63
// FAIL
// exit status 1
// FAIL    playground      0.006s

//<< go test -v
// запуск тестов с подробностями
// выведет статус по всем тестам, по пройденным и не пройденным

//<< go test -run "test_mane"
// запуск конкретного теста

//<< go test -v -run "test_mane"
// запуск конкретного теста с подробной инфой

//>> УСКОРЕНИЕ ТЕСТИРОВАНИЯ
// можно создать простой шаблон для тестирования на дженериках
// и сделать как сниппет
// так как любой тест - это прием проверяемого значения
// прием имени функции
// и сравнение

//>> ТАБЛИЧНОЕ ТЕСТИРОВАНИЕ
// нужно когда тестируеш много значений или вариантов

// делаю структуру с данными какие мне нужны
var testDataInt = []struct {
	arr      [8]int
	sum      int
	avg      float64
	reversed [8]int
}{
	{[8]int{4, 5, 6, 7, 8, 9, 0, 2}, 41, 5.125, [8]int{2, 0, 9, 8, 7, 6, 5, 4}},
	{[8]int{23, 4, 5, 56, 7, 36, 45, 8}, 184, 23, [8]int{8, 45, 36, 7, 56, 5, 4, 23}},
	{[8]int{8, 76, 5, 4, 3, 2, 8, 9}, 115, 14.375, [8]int{9, 8, 2, 3, 4, 5, 76, 8}},
	{[8]int{44, 3, 66, 7, 5, 8, 9, 5}, 147, 18.375, [8]int{5, 9, 8, 5, 7, 66, 3, 44}},
	{[8]int{4, 33, 2, 11, 12, 12, 13, 14}, 101, 12.625, [8]int{14, 13, 12, 12, 11, 2, 33, 4}},
	{[8]int{0, 0, 0, 0, 0, 0, 0, 0}, 0, 0, [8]int{0, 0, 0, 0, 0, 0, 0, 0}},
}

// и пишу тест
func TestSum(t *testing.T) {

	for index, num := range testDataInt {\
		// функция Run запускает подтест в тесте
		// первый параметр это имя подтеста
		// второй это функция подтеста
		t.Run("test #: "+strconv.Itoa(index), func(t *testing.T) {
			result := sum(num.arr)
			t.Log(result)
			if result != num.sum {
				t.Fatalf("wrong result, expected: %d, got: %d", num.sum, result)
			}
		})
	}
}
